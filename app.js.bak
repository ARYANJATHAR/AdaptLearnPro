// Quiz Components
const QuizApp = (function() {
    // State Management Component
    const State = {
        currentDifficulty: 1,
        correctStreak: 0,
        incorrectStreak: 0,
        answeredQuestions: [],
        currentQuestion: null,
        totalQuestions: 10,
        totalCorrect: 0,
        totalIncorrect: 0,
        totalAttempted: 0,
        highestDifficulty: 1,
        userSelections: [],
        questionHistory: [],
        selectedAnswerIndex: null,
        answerSubmitted: false,
        soundEnabled: true,
        
        reset() {
            this.currentDifficulty = 1;
            this.correctStreak = 0;
            this.incorrectStreak = 0;
            this.answeredQuestions = [];
            this.totalCorrect = 0;
            this.totalIncorrect = 0;
            this.totalAttempted = 0;
            this.highestDifficulty = 1;
            this.userSelections = [];
            this.questionHistory = [];
        }
    };
    
    // Audio Component
    const AudioManager = {
        correctSound: new Audio('correct.mp3'),
        incorrectSound: new Audio('wrong.mp3'),
        completionSound: new Audio('correct.mp3'),
        
        playCorrect() {
            if (State.soundEnabled) {
                this.correctSound.currentTime = 0;
                this.correctSound.play().catch(e => console.log("Audio play error:", e));
            }
        },
        
        playIncorrect() {
            if (State.soundEnabled) {
                this.incorrectSound.currentTime = 0;
                this.incorrectSound.play().catch(e => console.log("Audio play error:", e));
            }
        },
        
        playCompletion() {
            if (State.soundEnabled) {
                this.completionSound.currentTime = 0;
                this.completionSound.play().catch(e => console.log("Audio play error:", e));
            }
        },
        
        toggleSound() {
            State.soundEnabled = !State.soundEnabled;
            UI.soundToggle.innerHTML = State.soundEnabled ? 
                '<i class="fas fa-volume-up"></i>' : 
                '<i class="fas fa-volume-mute"></i>';
            
            UI.showFeedback(State.soundEnabled ? "Sound On" : "Sound Off", "bg-blue-500");
        }
    };
    
    // UI Component
    const UI = {
        // DOM Elements
        questionContainer: document.getElementById('question-container'),
        questionText: document.getElementById('question-text'),
        optionsContainer: document.getElementById('options-container'),
        nextButton: document.getElementById('next-btn'),
        restartButton: document.getElementById('restart-btn'),
        restartFinalButton: document.getElementById('final-restart-btn'),
        solutionsButton: document.getElementById('solutions-btn'),
        solutionsContainer: document.getElementById('solutions-container'),
        solutionsList: document.getElementById('solutions-list'),
        resultsDiv: document.getElementById('results'),
        navigationDiv: document.getElementById('navigation'),
        difficultyLevel: document.getElementById('difficulty-level'),
        difficultyBadge: document.getElementById('difficulty-badge'),
        correctDisplay: document.getElementById('correct'),
        incorrectDisplay: document.getElementById('incorrect'),
        attemptedDisplay: document.getElementById('attempted'),
        progressBar: document.getElementById('progress-bar'),
        progressText: document.getElementById('progress-text'),
        finalScoreDisplay: document.getElementById('final-score'),
        finalCorrectDisplay: document.getElementById('final-correct'),
        finalIncorrectDisplay: document.getElementById('final-incorrect'),
        highestDifficultyDisplay: document.getElementById('highest-difficulty'),
        feedbackMessage: document.getElementById('feedback-message'),
        soundToggle: document.getElementById('sound-toggle'),
        
        updateStats() {
            this.correctDisplay.textContent = State.totalCorrect;
            this.incorrectDisplay.textContent = State.totalIncorrect;
            this.attemptedDisplay.textContent = State.totalAttempted;
            this.difficultyLevel.textContent = State.currentDifficulty;
            
            // Update difficulty badge
            this.difficultyBadge.className = `difficulty-badge difficulty-${State.currentDifficulty} text-white text-xs px-2 py-1 rounded`;
            this.difficultyBadge.textContent = State.currentDifficulty === 1 ? 'Easy' : 
                                         State.currentDifficulty === 2 ? 'Medium' : 'Hard';
            
            // Update progress
            this.progressBar.style.width = `${(State.totalAttempted / State.totalQuestions) * 100}%`;
            this.progressText.textContent = `Question ${State.totalAttempted} of ${State.totalQuestions}`;
        },
        
        showFeedback(message, bgClass) {
            // Clear any existing messages first
            this.feedbackMessage.classList.remove('show');
            
            // Small delay before showing new message to ensure animation works
            setTimeout(() => {
                this.feedbackMessage.textContent = message;
                this.feedbackMessage.className = `feedback-message ${bgClass} show`;
                
                // Reset any previous timeout
                if (this.feedbackMessage.timeoutId) {
                    clearTimeout(this.feedbackMessage.timeoutId);
                }
                
                // Set new timeout to hide the message
                this.feedbackMessage.timeoutId = setTimeout(() => {
                    this.feedbackMessage.classList.remove('show');
                }, 2000);
            }, 50);
        },
        
        renderQuestion(question) {
            // Update question display
            this.questionText.textContent = question.question;
            this.optionsContainer.innerHTML = "";
            
            // Create option buttons
            question.options.forEach((option, index) => {
                const optionButton = document.createElement('button');
                optionButton.className = "option-btn w-full text-left px-4 py-3 rounded-lg border border-gray-200 hover:border-gray-300 transition-all";
                optionButton.innerHTML = `
                    <span class="inline-block w-6 h-6 rounded-full mr-3 bg-gray-100 text-gray-700 text-sm flex items-center justify-center">${String.fromCharCode(65 + index)}</span>
                    <span>${option}</span>
                `;
                
                optionButton.addEventListener('click', () => QuizLogic.selectAnswer(index, optionButton));
                this.optionsContainer.appendChild(optionButton);
            });
            
            // Apply fade in effect
            this.questionContainer.style.opacity = '1';
            this.questionContainer.classList.add('animate-fadeIn');
        },
        
        showResults() {
            // Calculate final score
            const score = State.totalAttempted > 0 ? Math.round((State.totalCorrect / State.totalAttempted) * 100) : 0;
            
            // Update results
            this.finalScoreDisplay.textContent = `${score}%`;
            this.finalCorrectDisplay.textContent = State.totalCorrect;
            this.finalIncorrectDisplay.textContent = State.totalIncorrect;
            this.highestDifficultyDisplay.textContent = State.highestDifficulty;
            
            // Show results view
            this.resultsDiv.classList.remove('hidden');
            
            return score;
        },
        
        showSolutions() {
            this.solutionsContainer.classList.remove('hidden');
            this.solutionsList.innerHTML = '';
            
            State.questionHistory.forEach((item, index) => {
                const solutionItem = document.createElement('div');
                solutionItem.className = `solution-item ${item.isCorrect ? 'bg-green-50' : 'bg-red-50'}`;
                
                const difficultyLabel = item.difficulty === 1 ? 'Easy' : 
                                       item.difficulty === 2 ? 'Medium' : 'Hard';
                
                const difficultyClass = item.difficulty === 1 ? 'bg-green-100 text-green-800' : 
                                       item.difficulty === 2 ? 'bg-yellow-100 text-yellow-800' : 
                                       'bg-red-100 text-red-800';
                
                solutionItem.innerHTML = `
                    <div class="flex justify-between items-start mb-3">
                        <h4 class="font-medium">Question ${index + 1}</h4>
                        <span class="px-2 py-1 rounded-full text-xs ${difficultyClass}">${difficultyLabel}</span>
                    </div>
                    <p class="mb-3">${item.question.question}</p>
                    <div class="space-y-2 mb-3">
                        ${item.question.options.map((opt, i) => `
                            <div class="flex items-center p-2 rounded ${
                                i === item.question.correctAnswer && i === item.userAnswer ? 'bg-green-100' :
                                i === item.question.correctAnswer ? 'bg-green-100' :
                                i === item.userAnswer ? 'bg-red-100' : 'bg-gray-50'
                            }">
                                <span class="inline-block w-6 h-6 rounded-full mr-2 
                                    ${i === item.question.correctAnswer ? 'bg-green-200 text-green-800' : 
                                      i === item.userAnswer ? 'bg-red-200 text-red-800' : 'bg-gray-200 text-gray-600'} 
                                    text-sm flex items-center justify-center">${String.fromCharCode(65 + i)}</span>
                                <span>${opt}</span>
                                ${i === item.question.correctAnswer ? 
                                    '<span class="ml-auto"><i class="fas fa-check text-green-600"></i></span>' : 
                                    i === item.userAnswer && i !== item.question.correctAnswer ? 
                                    '<span class="ml-auto"><i class="fas fa-times text-red-600"></i></span>' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.solutionsList.appendChild(solutionItem);
            });
            
            // Change button text after showing solutions
            this.solutionsButton.innerHTML = '<i class="fas fa-eye-slash mr-2"></i><span>Hide Solutions</span>';
            this.solutionsButton.addEventListener('click', () => {
                if (this.solutionsContainer.classList.contains('hidden')) {
                    this.showSolutions();
                } else {
                    this.solutionsContainer.classList.add('hidden');
                    this.solutionsButton.innerHTML = '<i class="fas fa-eye mr-2"></i><span>View Solutions</span>';
                }
            }, { once: true });
        }
    };
    
    // Confetti Animation Component
    const ConfettiManager = {
        maxParticleCount: 150,
        particleSpeed: 2,
        confettiCanvas: null,
        context: null,
        particles: [],
        animationId: null,
        
        startConfetti() {
            // Create canvas if it doesn't exist
            if (!this.confettiCanvas) {
                this.confettiCanvas = document.createElement('canvas');
                this.confettiCanvas.id = 'confetti-canvas';
                this.confettiCanvas.style.position = 'fixed';
                this.confettiCanvas.style.top = '0';
                this.confettiCanvas.style.left = '0';
                this.confettiCanvas.style.width = '100%';
                this.confettiCanvas.style.height = '100%';
                this.confettiCanvas.style.pointerEvents = 'none';
                this.confettiCanvas.style.zIndex = '1000';
                document.body.appendChild(this.confettiCanvas);
                
                // Get the canvas context
                this.context = this.confettiCanvas.getContext('2d');
            }
            
            // Set canvas dimensions
            this.confettiCanvas.width = window.innerWidth;
            this.confettiCanvas.height = window.innerHeight;
            
            // Create particles
            this.particles = [];
            for (let i = 0; i < this.maxParticleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.confettiCanvas.width,
                    y: Math.random() * this.confettiCanvas.height - this.confettiCanvas.height,
                    r: Math.random() * 5 + 5, // radius
                    d: Math.random() * this.maxParticleCount, // density
                    color: this.getRandomColor(),
                    tilt: Math.floor(Math.random() * 10) - 10,
                    opacity: Math.random() + 0.5,
                    shape: Math.floor(Math.random() * 2) // 0 for circle, 1 for rectangle
                });
            }
            
            // Start animation
            this.animateConfetti();
        },
        
        animateConfetti() {
            this.context.clearRect(0, 0, this.confettiCanvas.width, this.confettiCanvas.height);
            
            for (let i = 0; i < this.maxParticleCount; i++) {
                let p = this.particles[i];
                this.context.beginPath();
                this.context.globalAlpha = p.opacity;
                
                if (p.shape === 0) {
                    // Draw circle
                    this.context.fillStyle = p.color;
                    this.context.arc(p.x, p.y, p.r, 0, Math.PI * 2, false);
                } else {
                    // Draw rectangle
                    this.context.fillStyle = p.color;
                    this.context.rect(p.x, p.y, p.r * 2, p.r * 2);
                }
                
                this.context.closePath();
                this.context.fill();
                
                // Move particles
                p.y += this.particleSpeed;
                p.tilt = Math.sin(p.d) * 15;
                
                // Reset particles when they reach bottom
                if (p.y > this.confettiCanvas.height) {
                    this.particles[i] = {
                        x: Math.random() * this.confettiCanvas.width,
                        y: -10,
                        r: p.r,
                        d: p.d,
                        color: this.getRandomColor(),
                        tilt: Math.floor(Math.random() * 10) - 10,
                        opacity: Math.random() + 0.5,
                        shape: Math.floor(Math.random() * 2)
                    };
                }
            }
            
            this.animationId = requestAnimationFrame(() => this.animateConfetti());
        },
        
        stopConfetti() {
            cancelAnimationFrame(this.animationId);
            
            // Remove canvas after a delay
            setTimeout(() => {
                if (this.confettiCanvas) {
                    this.confettiCanvas.remove();
                    this.confettiCanvas = null;
                }
            }, 100);
        },
        
        getRandomColor() {
            const colors = [
                '#FF5252', // red
                '#FF9800', // orange
                '#FFEB3B', // yellow
                '#4CAF50', // green
                '#2196F3', // blue
                '#673AB7', // purple
                '#E91E63'  // pink
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
    };
    
    // Quiz Logic Component
    const QuizLogic = {
        initQuiz() {
            State.reset();
            UI.updateStats();
            this.loadNextQuestion();
            UI.resultsDiv.classList.add('hidden');
            UI.navigationDiv.classList.remove('hidden');
        },
        
        loadNextQuestion() {
            State.answerSubmitted = false;
            State.selectedAnswerIndex = null;
            
            // Apply fade out effect
            UI.questionContainer.style.opacity = '0';
            
            setTimeout(() => {
                // Get available questions at current difficulty
                let availableQuestions = questions[State.currentDifficulty].filter(
                    q => !State.answeredQuestions.includes(q.question)
                );
                
                // If no more questions at current difficulty, try other difficulties
                if (availableQuestions.length === 0) {
                    const allDifficulties = Object.keys(questions).map(Number);
                    for (const diff of allDifficulties) {
                        if (diff !== State.currentDifficulty) {
                            availableQuestions = questions[diff].filter(
                                q => !State.answeredQuestions.includes(q.question)
                            );
                            if (availableQuestions.length > 0) break;
                        }
                    }
                }
                
                // If still no questions or reached total questions, end the quiz
                if (availableQuestions.length === 0 || State.totalAttempted >= State.totalQuestions) {
                    this.endQuiz();
                    return;
                }
                
                // Select a random question from available questions
                const randomIndex = Math.floor(Math.random() * availableQuestions.length);
                State.currentQuestion = availableQuestions[randomIndex];
                
                // Mark question as answered
                State.answeredQuestions.push(State.currentQuestion.question);
                
                // Render the question
                UI.renderQuestion(State.currentQuestion);
                
                // Update progress
                State.totalAttempted++;
                UI.updateStats();
                
            }, 300); // Delay to match the fade out effect
        },
        
        selectAnswer(index, button) {
            if (State.answerSubmitted) return;
            
            // Remove selection from all options
            const allOptions = UI.optionsContainer.querySelectorAll('.option-btn');
            allOptions.forEach(opt => opt.classList.remove('selected'));
            
            // Mark the selected option
            button.classList.add('selected');
            State.selectedAnswerIndex = index;
            
            // Enable submit button if disabled
            UI.nextButton.disabled = false;
            
            // Auto-submit after a short delay - increased for better user experience
            setTimeout(() => {
                this.submitAnswer();
            }, 300);
        },
        
        submitAnswer() {
            if (State.selectedAnswerIndex === null || State.answerSubmitted) return;
            
            State.answerSubmitted = true;
            const isCorrect = State.selectedAnswerIndex === State.currentQuestion.correctAnswer;
            
            // Track user's answer for review
            State.userSelections.push({
                question: State.currentQuestion.question,
                options: State.currentQuestion.options,
                correctAnswer: State.currentQuestion.correctAnswer,
                userAnswer: State.selectedAnswerIndex,
                isCorrect: isCorrect
            });
            
            // Store question in history
            State.questionHistory.push({
                question: State.currentQuestion,
                userAnswer: State.selectedAnswerIndex,
                isCorrect: isCorrect,
                difficulty: State.currentDifficulty
            });
            
            // First apply styling to options
            const selectedOption = UI.optionsContainer.querySelectorAll('.option-btn')[State.selectedAnswerIndex];
            
            // Update streaks and difficulty
            if (isCorrect) {
                State.totalCorrect++;
                State.correctStreak++;
                State.incorrectStreak = 0;
                
                // Play correct sound
                AudioManager.playCorrect();
                
                // Apply correct styling
                selectedOption.classList.add('correct');
                selectedOption.classList.add('animate-pulse');
                
                // Show feedback after a tiny delay to ensure visual changes are noticed first
                setTimeout(() => {
                    UI.showFeedback("Correct!", "bg-green-500");
                    
                    // Increase difficulty after 3 correct answers in a row
                    if (State.correctStreak >= 3 && State.currentDifficulty < 3) {
                        State.currentDifficulty++;
                        State.highestDifficulty = Math.max(State.highestDifficulty, State.currentDifficulty);
                        State.correctStreak = 0;
                        
                        // Show level up feedback after a short delay
                        setTimeout(() => {
                            UI.showFeedback("Level Up! Questions will get harder", "bg-blue-500");
                        }, 1200);
                    }
                    
                    // Auto-move to next question after a delay
                    setTimeout(() => {
                        this.loadNextQuestion();
                    }, 1800);
                }, 100);
            } else {
                State.totalIncorrect++;
                State.incorrectStreak++;
                State.correctStreak = 0;
                
                // Play incorrect sound
                AudioManager.playIncorrect();
                
                // Apply incorrect styling
                selectedOption.classList.add('incorrect');
                
                // Show correct answer
                const correctOption = UI.optionsContainer.querySelectorAll('.option-btn')[State.currentQuestion.correctAnswer];
                correctOption.classList.add('correct');
                
                // Show feedback after a tiny delay
                setTimeout(() => {
                    UI.showFeedback("Incorrect!", "bg-red-500");
                    
                    // Decrease difficulty after 2 incorrect answers in a row
                    if (State.incorrectStreak >= 2 && State.currentDifficulty > 1) {
                        State.currentDifficulty--;
                        State.incorrectStreak = 0;
                        
                        // Show difficulty adjustment feedback after a short delay
                        setTimeout(() => {
                            UI.showFeedback("Adjusting difficulty for better learning", "bg-blue-500");
                        }, 1200);
                    }
                    
                    // Auto-move to next question after a delay
                    setTimeout(() => {
                        this.loadNextQuestion();
                    }, 1800);
                }, 100);
            }
            
            // Update stats display
            UI.updateStats();
            
            // Enable next button
            UI.nextButton.disabled = false;
            UI.nextButton.focus();
        },
        
        endQuiz() {
            // Hide question container and navigation
            UI.navigationDiv.classList.add('hidden');
            
            // Show results
            const score = UI.showResults();
            
            // Play completion sound
            AudioManager.playCompletion();
            
            // Trigger confetti celebration if score is good
            if (score >= 60) {
                ConfettiManager.startConfetti();
                setTimeout(() => {
                    ConfettiManager.stopConfetti();
                }, 3000);
            }
        }
    };
    
    // Initialize and set up event listeners
    function init() {
        // Event Listeners
        UI.nextButton.addEventListener('click', () => QuizLogic.loadNextQuestion());
        
        UI.restartButton.addEventListener('click', () => {
            if (confirm('Are you sure you want to restart the quiz? Your progress will be lost.')) {
                QuizLogic.initQuiz();
            }
        });
        
        UI.restartFinalButton.addEventListener('click', () => QuizLogic.initQuiz());
        
        UI.solutionsButton.addEventListener('click', () => UI.showSolutions());
        
        // Add event listener for sound toggle if it exists
        if (UI.soundToggle) {
            UI.soundToggle.addEventListener('click', () => AudioManager.toggleSound());
        }
        
        // Handle window resize for confetti
        window.addEventListener('resize', () => {
            if (ConfettiManager.confettiCanvas) {
                ConfettiManager.confettiCanvas.width = window.innerWidth;
                ConfettiManager.confettiCanvas.height = window.innerHeight;
            }
        });
        
        // Initialize the quiz
        QuizLogic.initQuiz();
    }
    
    // Return public methods
    return {
        init
    };
})();

// Initialize the app when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    QuizApp.init();
}); 